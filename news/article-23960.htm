<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
        <link rel="canonical" href="https://clashnyanpasu.github.io/news/article-23960.htm" />
    <meta charset="utf-8">
    <!--====== Title ======-->
    <title>【mq】从零开始实现 mq-03-引入 broker 中间人_在线工具</title>
        <meta name="description" content="【mq】从零开始实现 mq-01-生产者、消费者启动  【mq】从零开始实现 mq-02-如何实现生产者调用消费者？ 【mq】从零开始实现 mq-03-引入 broker 中间人 上一节我们学习了如何" />
        <link rel="icon" href="/assets/website/img/clashnyanpasu/favicon.ico" type="image/x-icon"/>

    <meta name="author" content="ClashNyanpasu官网节点站">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://clashnyanpasu.github.io/news/article-23960.htm" />
    <meta property="og:site_name" content="ClashNyanpasu官网节点站" />
    <meta property="og:title" content="【mq】从零开始实现 mq-03-引入 broker 中间人_在线工具" />
    <meta property="og:image" content="https://clashnyanpasu.github.io/uploads/20240623/6974ac56e150922672f67973b614e4eb.webp" />
        <meta property="og:release_date" content="2024-12-10T10:00:13" />
    <meta property="og:updated_time" content="2024-12-10T10:00:13" />
        <meta property="og:description" content="【mq】从零开始实现 mq-01-生产者、消费者启动  【mq】从零开始实现 mq-02-如何实现生产者调用消费者？ 【mq】从零开始实现 mq-03-引入 broker 中间人 上一节我们学习了如何" />
        
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!--====== Magnific Popup CSS ======-->
    <link rel="stylesheet" href="/assets/website/css/clashnyanpasu/magnific-popup.css">
    <!--====== Slick CSS ======-->
    <link rel="stylesheet" href="/assets/website/css/clashnyanpasu/slick.css">
    <!--====== Line Icons CSS ======-->
    <link rel="stylesheet" href="/assets/website/css/clashnyanpasu/LineIcons.css">
    <!--====== Bootstrap CSS ======-->
    <link rel="stylesheet" href="/assets/website/css/clashnyanpasu/bootstrap.min.css">
    <!--====== Default CSS ======-->
    <link rel="stylesheet" href="/assets/website/css/clashnyanpasu/default.css">
    <!--====== Style CSS ======-->
    <link rel="stylesheet" href="/assets/website/css/clashnyanpasu/style.css">

    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="【mq】从零开始实现 mq-03-引入 broker 中间人_在线工具">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7F56WL29Y8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7F56WL29Y8');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
        <!--====== PRELOADER PART START ======-->
    <div class="preloader">
        <div class="loader">
            <div class="ytp-spinner">
                <div class="ytp-spinner-container">
                    <div class="ytp-spinner-rotator">
                        <div class="ytp-spinner-left">
                            <div class="ytp-spinner-circle"></div>
                        </div>
                        <div class="ytp-spinner-right">
                            <div class="ytp-spinner-circle"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!--====== PRELOADER PART ENDS ======-->
    <!--====== NAVBAR TWO PART START ======-->
    <section class="navbar-area">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <nav class="navbar navbar-expand-lg">
                                                <a class="navbar-brand top" href="/">
                            Clash Nyanpasu                        </a>
                                                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTwo" aria-controls="navbarTwo" aria-expanded="false" aria-label="Toggle navigation">
                            <span class="toggler-icon"></span>
                            <span class="toggler-icon"></span>
                            <span class="toggler-icon"></span>
                        </button>
                        <div class="collapse navbar-collapse sub-menu-bar" id="navbarTwo">
                            <ul class="navbar-nav m-auto">
                                                                <li class="nav-item"><a href="/">首页</a></li>
                                                                <li class="nav-item"><a href="/free-nodes/">免费节点</a></li>
                                                                <li class="nav-item"><a href="/paid-subscribe/">推荐机场</a></li>
                                                                <li class="nav-item"><a href="/client.htm">客户端</a></li>
                                                                <li class="nav-item"><a href="/news/">新闻资讯</a></li>
                                                            </ul>
                        </div>

                    </nav> <!-- navbar -->
                </div>
            </div> <!-- row -->
        </div> <!-- container -->
    </section>
    <!--====== NAVBAR TWO PART ENDS ======-->
    <!--====== SLIDER PART START ======-->
    <section id="home" class="slider_area">
        <div id="carouselThree" class="carousel slide sub-page" data-ride="carousel">
            <div class="carousel-inner">
                <div class="carousel-item active">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-6">
                                <div class="slider-content">
                                    <h1 class="title">【mq】从零开始实现 mq-03-引入 broker 中间人_在线工具</h1>
                                    <p class="text">
                                        <a href="/">首页</a> / 
                                        <a href="/news/">新闻资讯</a> / 
                                        <span>正文</span>
                                    </p>
                                </div>
                            </div>
                        </div> <!-- row -->
                    </div> <!-- container -->
                    <div class="slider-image-box d-none d-lg-flex align-items-end">
                        <div class="slider-image">
                            <img src="/assets/website/img/clashnyanpasu/slider/1.png" alt="Hero">
                        </div> <!-- slider-imgae -->
                    </div> <!-- slider-imgae box -->
                </div> <!-- carousel-item -->
            </div>
        </div>
    </section>
    <!--====== SLIDER PART ENDS ======-->
    <!--====== ABOUT PART START ======-->
    <section id=about class=about-area>
        <div class=container>
            <div class="row">
                <div class="col-md-9">
                                    <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				</h1> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://mp.weixin.qq.com/s/moF528JiVG9dqCi5oFMbVg"  target="_blank"  rel="nofollow">【mq】从零开始实现 mq-01-生产者、消费者启动 </a></p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://mp.weixin.qq.com/s/_OF4hbh9llaxN27Cv_cToQ"  target="_blank"  rel="nofollow">【mq】从零开始实现 mq-02-如何实现生产者调用消费者？</a></p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://mp.weixin.qq.com/s/BvEWsLp3_35yFVRqBOxS2w"  target="_blank"  rel="nofollow">【mq】从零开始实现 mq-03-引入 broker 中间人</a></p> <p>上一节我们学习了如何实现生产者给消费者发送消息，但是是通过直连的方式。</p> <p>那么如何才能达到解耦的效果呢？</p> <p>答案就是引入 broker，消息的中间人。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220430/0b1fdc6598053fbf88a8e516da6c2ea3.jpg" alt="【mq】从零开始实现 mq-03-引入 broker 中间人_在线工具"></p> </h1> <h2 id="核心启动类">核心启动类</h2> <p>类似我们前面 consumer 的启动实现：</p> <pre><code class="language-java">package com.github.houbb.mq.broker.core;  /**  * @author binbin.hou  * @since 1.0.0  */ public class MqBroker extends Thread implements IMqBroker {      // 省略     private ChannelHandler initChannelHandler() {         MqBrokerHandler handler = new MqBrokerHandler();         handler.setInvokeService(invokeService);         handler.setRegisterConsumerService(registerConsumerService);         handler.setRegisterProducerService(registerProducerService);         handler.setMqBrokerPersist(mqBrokerPersist);         handler.setBrokerPushService(brokerPushService);         handler.setRespTimeoutMills(respTimeoutMills);          return handler;     }      @Override     public void run() {         // 启动服务端         log.info("MQ 中间人开始启动服务端 port: {}", port);          EventLoopGroup bossGroup = new NioEventLoopGroup();         EventLoopGroup workerGroup = new NioEventLoopGroup();          try {             final ByteBuf delimiterBuf = DelimiterUtil.getByteBuf(DelimiterUtil.DELIMITER);             ServerBootstrap serverBootstrap = new ServerBootstrap();             serverBootstrap.group(workerGroup, bossGroup)                     .channel(NioServerSocketChannel.class)                     .childHandler(new ChannelInitializer&lt;Channel&gt;() {                         @Override                         protected void initChannel(Channel ch) throws Exception {                             ch.pipeline()                                     .addLast(new DelimiterBasedFrameDecoder(DelimiterUtil.LENGTH, delimiterBuf))                                     .addLast(initChannelHandler());                         }                     })                     // 这个参数影响的是还没有被accept 取出的连接                     .option(ChannelOption.SO_BACKLOG, 128)                     // 这个参数只是过一段时间内客户端没有响应，服务端会发送一个 ack 包，以判断客户端是否还活着。                     .childOption(ChannelOption.SO_KEEPALIVE, true);              // 绑定端口，开始接收进来的链接             ChannelFuture channelFuture = serverBootstrap.bind(port).syncUninterruptibly();             log.info("MQ 中间人启动完成，监听【" + port + "】端口");              channelFuture.channel().closeFuture().syncUninterruptibly();             log.info("MQ 中间人关闭完成");         } catch (Exception e) {             log.error("MQ 中间人启动异常", e);             throw new MqException(BrokerRespCode.RPC_INIT_FAILED);         } finally {             workerGroup.shutdownGracefully();             bossGroup.shutdownGracefully();         }     }  } </code></pre> <p><code>initChannelHandler</code> 中有不少新面孔，我们后面会详细介绍。</p> <h2 id="mqbrokerhandler-处理逻辑">MqBrokerHandler 处理逻辑</h2> <pre><code class="language-java">package com.github.houbb.mq.broker.handler;  import java.util.List;  /**  * @author binbin.hou  * @since 1.0.0  */ public class MqBrokerHandler extends SimpleChannelInboundHandler {      private static final Log log = LogFactory.getLog(MqBrokerHandler.class);      /**      * 调用管理类      * @since 1.0.0      */     private IInvokeService invokeService;      /**      * 消费者管理      * @since 0.0.3      */     private IBrokerConsumerService registerConsumerService;      /**      * 生产者管理      * @since 0.0.3      */     private IBrokerProducerService registerProducerService;      /**      * 持久化类      * @since 0.0.3      */     private IMqBrokerPersist mqBrokerPersist;      /**      * 推送服务      * @since 0.0.3      */     private IBrokerPushService brokerPushService;      /**      * 获取响应超时时间      * @since 0.0.3      */     private long respTimeoutMills;      //set 方法       @Override     protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {         ByteBuf byteBuf = (ByteBuf) msg;         byte[] bytes = new byte[byteBuf.readableBytes()];         byteBuf.readBytes(bytes);          RpcMessageDto rpcMessageDto = null;         try {             rpcMessageDto = JSON.parseObject(bytes, RpcMessageDto.class);         } catch (Exception exception) {             log.error("RpcMessageDto json 格式转换异常 {}", new String(bytes));             return;         }          if (rpcMessageDto.isRequest()) {             MqCommonResp commonResp = this.dispatch(rpcMessageDto, ctx);              if(commonResp == null) {                 log.debug("当前消息为 null，忽略处理。");                 return;             }              // 写回响应，和以前类似。                  writeResponse(rpcMessageDto, commonResp, ctx);         } else {             final String traceId = rpcMessageDto.getTraceId();              // 丢弃掉 traceId 为空的信息             if(StringUtil.isBlank(traceId)) {                 log.debug("[Server Response] response traceId 为空，直接丢弃", JSON.toJSON(rpcMessageDto));                 return;             }              // 添加消息             invokeService.addResponse(traceId, rpcMessageDto);         }     }      /**      * 异步处理消息      * @param mqMessage 消息      * @since 0.0.3      */     private void asyncHandleMessage(MqMessage mqMessage) {         List&lt;Channel&gt; channelList = registerConsumerService.getSubscribeList(mqMessage);         if(CollectionUtil.isEmpty(channelList)) {             log.info("监听列表为空，忽略处理");             return;         }          BrokerPushContext brokerPushContext = new BrokerPushContext();         brokerPushContext.setChannelList(channelList);         brokerPushContext.setMqMessage(mqMessage);         brokerPushContext.setMqBrokerPersist(mqBrokerPersist);         brokerPushContext.setInvokeService(invokeService);         brokerPushContext.setRespTimeoutMills(respTimeoutMills);          brokerPushService.asyncPush(brokerPushContext);     } } </code></pre> <h2 id="消息分发">消息分发</h2> <p>broker 接收到消息以后，dispatch 实现如下：</p> <pre><code class="language-java">/**  * 消息的分发  *  * @param rpcMessageDto 入参  * @param ctx 上下文  * @return 结果  */ private MqCommonResp dispatch(RpcMessageDto rpcMessageDto, ChannelHandlerContext ctx) {     try {         final String methodType = rpcMessageDto.getMethodType();         final String json = rpcMessageDto.getJson();         String channelId = ChannelUtil.getChannelId(ctx);         final Channel channel = ctx.channel();         log.debug("channelId: {} 接收到 method: {} 内容：{}", channelId,                 methodType, json);          // 生产者注册         if(MethodType.P_REGISTER.equals(methodType)) {             BrokerRegisterReq registerReq = JSON.parseObject(json, BrokerRegisterReq.class);             return registerProducerService.register(registerReq.getServiceEntry(), channel);         }         // 生产者注销         if(MethodType.P_UN_REGISTER.equals(methodType)) {             BrokerRegisterReq registerReq = JSON.parseObject(json, BrokerRegisterReq.class);             return registerProducerService.unRegister(registerReq.getServiceEntry(), channel);         }         // 生产者消息发送         if(MethodType.P_SEND_MSG.equals(methodType)) {             MqMessage mqMessage = JSON.parseObject(json, MqMessage.class);             MqMessagePersistPut persistPut = new MqMessagePersistPut();             persistPut.setMqMessage(mqMessage);             persistPut.setMessageStatus(MessageStatusConst.WAIT_CONSUMER);             MqCommonResp commonResp = mqBrokerPersist.put(persistPut);             this.asyncHandleMessage(mqMessage);             return commonResp;         }         // 生产者消息发送-ONE WAY         if(MethodType.P_SEND_MSG_ONE_WAY.equals(methodType)) {             MqMessage mqMessage = JSON.parseObject(json, MqMessage.class);             MqMessagePersistPut persistPut = new MqMessagePersistPut();             persistPut.setMqMessage(mqMessage);             persistPut.setMessageStatus(MessageStatusConst.WAIT_CONSUMER);             mqBrokerPersist.put(persistPut);             this.asyncHandleMessage(mqMessage);             return null;         }          // 消费者注册         if(MethodType.C_REGISTER.equals(methodType)) {             BrokerRegisterReq registerReq = JSON.parseObject(json, BrokerRegisterReq.class);             return registerConsumerService.register(registerReq.getServiceEntry(), channel);         }         // 消费者注销         if(MethodType.C_UN_REGISTER.equals(methodType)) {             BrokerRegisterReq registerReq = JSON.parseObject(json, BrokerRegisterReq.class);             return registerConsumerService.unRegister(registerReq.getServiceEntry(), channel);         }         // 消费者监听注册         if(MethodType.C_SUBSCRIBE.equals(methodType)) {             ConsumerSubscribeReq req = JSON.parseObject(json, ConsumerSubscribeReq.class);             return registerConsumerService.subscribe(req, channel);         }         // 消费者监听注销         if(MethodType.C_UN_SUBSCRIBE.equals(methodType)) {             ConsumerUnSubscribeReq req = JSON.parseObject(json, ConsumerUnSubscribeReq.class);             return registerConsumerService.unSubscribe(req, channel);         }          // 消费者主动 pull         if(MethodType.C_MESSAGE_PULL.equals(methodType)) {             MqConsumerPullReq req = JSON.parseObject(json, MqConsumerPullReq.class);             return mqBrokerPersist.pull(req, channel);         }         throw new UnsupportedOperationException("暂不支持的方法类型");     } catch (Exception exception) {         log.error("执行异常", exception);         MqCommonResp resp = new MqCommonResp();         resp.setRespCode(MqCommonRespCode.FAIL.getCode());         resp.setRespMessage(MqCommonRespCode.FAIL.getMsg());         return resp;     } } </code></pre> <h3 id="消息推送">消息推送</h3> <p><code>this.asyncHandleMessage(mqMessage);</code> 是 broker 接收到消息之后的处理逻辑。</p> <pre><code class="language-java">/**  * 异步处理消息  * @param mqMessage 消息  * @since 0.0.3  */ private void asyncHandleMessage(MqMessage mqMessage) {     List&lt;Channel&gt; channelList = registerConsumerService.getSubscribeList(mqMessage);     if(CollectionUtil.isEmpty(channelList)) {         log.info("监听列表为空，忽略处理");         return;     }      BrokerPushContext brokerPushContext = new BrokerPushContext();     brokerPushContext.setChannelList(channelList);     brokerPushContext.setMqMessage(mqMessage);     brokerPushContext.setMqBrokerPersist(mqBrokerPersist);     brokerPushContext.setInvokeService(invokeService);     brokerPushContext.setRespTimeoutMills(respTimeoutMills);     brokerPushService.asyncPush(brokerPushContext); } </code></pre> <p>推送的核心实现如下：</p> <pre><code class="language-java">package com.github.houbb.mq.broker.support.push;  /**  * @author binbin.hou  * @since 0.0.3  */ public class BrokerPushService implements IBrokerPushService {      private static final Log log = LogFactory.getLog(BrokerPushService.class);      private static final ExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadExecutor();      @Override     public void asyncPush(final BrokerPushContext context) {         EXECUTOR_SERVICE.submit(new Runnable() {             @Override             public void run() {                 log.info("开始异步处理 {}", JSON.toJSON(context));                 final List&lt;Channel&gt; channelList = context.getChannelList();                 final IMqBrokerPersist mqBrokerPersist = context.getMqBrokerPersist();                 final MqMessage mqMessage = context.getMqMessage();                 final String messageId = mqMessage.getTraceId();                 final IInvokeService invokeService = context.getInvokeService();                 final long responseTime = context.getRespTimeoutMills();                  for(Channel channel : channelList) {                     try {                         String channelId = ChannelUtil.getChannelId(channel);                          log.info("开始处理 channelId: {}", channelId);                         //1. 调用                         mqMessage.setMethodType(MethodType.B_MESSAGE_PUSH);                         MqConsumerResultResp resultResp = callServer(channel, mqMessage,                                 MqConsumerResultResp.class, invokeService, responseTime);                          //2. 更新状态                         mqBrokerPersist.updateStatus(messageId, resultResp.getConsumerStatus());                          //3. 后期添加重试策略                          log.info("完成处理 channelId: {}", channelId);                     } catch (Exception exception) {                         log.error("处理异常");                         mqBrokerPersist.updateStatus(messageId, ConsumerStatus.FAILED.getCode());                     }                 }                  log.info("完成异步处理");             }         });     } } </code></pre> <p>此处在消息推送之后，需要更新消息的 ACK 状态。</p> <h3 id="消息生产者处理类">消息生产者处理类</h3> <p><code>IBrokerProducerService</code> 接口定义如下：</p> <pre><code class="language-java">package com.github.houbb.mq.broker.api;  /**  * &lt;p&gt; 生产者注册服务类 &lt;/p&gt;  *  * @author houbinbin  * @since 0.0.3  */ public interface IBrokerProducerService {      /**      * 注册当前服务信息      * （1）将该服务通过 {@link ServiceEntry#getGroupName()} 进行分组      * 订阅了这个 serviceId 的所有客户端      * @param serviceEntry 注册当前服务信息      * @param channel channel      * @since 0.0.8      */     MqCommonResp register(final ServiceEntry serviceEntry, Channel channel);      /**      * 注销当前服务信息      * @param serviceEntry 注册当前服务信息      * @param channel 通道      * @since 0.0.8      */     MqCommonResp unRegister(final ServiceEntry serviceEntry, Channel channel);      /**      * 获取服务地址信息      * @param channel channel      * @return 结果      * @since 0.0.3      */     ServiceEntry getServiceEntry(final Channel channel);  } </code></pre> <p>实现如下：</p> <p>本地基于 map 存储请求过来的基本信息。</p> <pre><code class="language-java">package com.github.houbb.mq.broker.support.api;  /**  * &lt;p&gt; 生产者注册服务类 &lt;/p&gt;  *  * @author houbinbin  * @since 0.0.3  */ public class LocalBrokerProducerService implements IBrokerProducerService {      private static final Log log = LogFactory.getLog(LocalBrokerProducerService.class);      private final Map&lt;String, BrokerServiceEntryChannel&gt; registerMap = new ConcurrentHashMap&lt;&gt;();      @Override     public MqCommonResp register(ServiceEntry serviceEntry, Channel channel) {         final String channelId = ChannelUtil.getChannelId(channel);         BrokerServiceEntryChannel entryChannel = InnerChannelUtils.buildEntryChannel(serviceEntry, channel);         registerMap.put(channelId, entryChannel);           MqCommonResp resp = new MqCommonResp();         resp.setRespCode(MqCommonRespCode.SUCCESS.getCode());         resp.setRespMessage(MqCommonRespCode.SUCCESS.getMsg());         return resp;     }      @Override     public MqCommonResp unRegister(ServiceEntry serviceEntry, Channel channel) {         final String channelId = ChannelUtil.getChannelId(channel);         registerMap.remove(channelId);          MqCommonResp resp = new MqCommonResp();         resp.setRespCode(MqCommonRespCode.SUCCESS.getCode());         resp.setRespMessage(MqCommonRespCode.SUCCESS.getMsg());         return resp;     }      @Override     public ServiceEntry getServiceEntry(Channel channel) {         final String channelId = ChannelUtil.getChannelId(channel);         return registerMap.get(channelId);     }  } </code></pre> <h3 id="消息消费者处理类">消息消费者处理类</h3> <p>接口定义如下：</p> <pre><code class="language-java">package com.github.houbb.mq.broker.api;  /**  * &lt;p&gt; 消费者注册服务类 &lt;/p&gt;  *  * @author houbinbin  * @since 0.0.3  */ public interface IBrokerConsumerService {      /**      * 注册当前服务信息      * （1）将该服务通过 {@link ServiceEntry#getGroupName()} 进行分组      * 订阅了这个 serviceId 的所有客户端      * @param serviceEntry 注册当前服务信息      * @param channel channel      * @since 0.0.3      */     MqCommonResp register(final ServiceEntry serviceEntry, Channel channel);      /**      * 注销当前服务信息      * @param serviceEntry 注册当前服务信息      * @param channel channel      * @since 0.0.3      */     MqCommonResp unRegister(final ServiceEntry serviceEntry, Channel channel);      /**      * 监听服务信息      * （1）监听之后，如果有任何相关的机器信息发生变化，则进行推送。      * （2）内置的信息，需要传送 ip 信息到注册中心。      *      * @param serviceEntry 客户端明细信息      * @param clientChannel 客户端 channel 信息      * @since 0.0.3      */     MqCommonResp subscribe(final ConsumerSubscribeReq serviceEntry,                    final Channel clientChannel);      /**      * 取消监听服务信息      * （1）监听之后，如果有任何相关的机器信息发生变化，则进行推送。      * （2）内置的信息，需要传送 ip 信息到注册中心。      *      * @param serviceEntry 客户端明细信息      * @param clientChannel 客户端 channel 信息      * @since 0.0.3      */     MqCommonResp unSubscribe(final ConsumerUnSubscribeReq serviceEntry,                    final Channel clientChannel);      /**      * 获取所有匹配的消费者      * 1. 同一个 groupName 只返回一个，注意负载均衡      * 2. 返回匹配当前消息的消费者通道      *      * @param mqMessage 消息体      * @return 结果      */     List&lt;Channel&gt; getSubscribeList(MqMessage mqMessage);  } </code></pre> <p>默认实现：</p> <pre><code class="language-java">package com.github.houbb.mq.broker.support.api;  /**  * @author binbin.hou  * @since 1.0.0  */ public class LocalBrokerConsumerService implements IBrokerConsumerService {      private final Map&lt;String, BrokerServiceEntryChannel&gt; registerMap = new ConcurrentHashMap&lt;&gt;();      /**      * 订阅集合      * key: topicName      * value: 对应的订阅列表      */     private final Map&lt;String, Set&lt;ConsumerSubscribeBo&gt;&gt; subscribeMap = new ConcurrentHashMap&lt;&gt;();      @Override     public MqCommonResp register(ServiceEntry serviceEntry, Channel channel) {         final String channelId = ChannelUtil.getChannelId(channel);         BrokerServiceEntryChannel entryChannel = InnerChannelUtils.buildEntryChannel(serviceEntry, channel);         registerMap.put(channelId, entryChannel);          MqCommonResp resp = new MqCommonResp();         resp.setRespCode(MqCommonRespCode.SUCCESS.getCode());         resp.setRespMessage(MqCommonRespCode.SUCCESS.getMsg());         return resp;     }      @Override     public MqCommonResp unRegister(ServiceEntry serviceEntry, Channel channel) {         final String channelId = ChannelUtil.getChannelId(channel);         registerMap.remove(channelId);          MqCommonResp resp = new MqCommonResp();         resp.setRespCode(MqCommonRespCode.SUCCESS.getCode());         resp.setRespMessage(MqCommonRespCode.SUCCESS.getMsg());         return resp;     }      @Override     public MqCommonResp subscribe(ConsumerSubscribeReq serviceEntry, Channel clientChannel) {         final String channelId = ChannelUtil.getChannelId(clientChannel);         final String topicName = serviceEntry.getTopicName();          Set&lt;ConsumerSubscribeBo&gt; set = subscribeMap.get(topicName);         if(set == null) {             set = new HashSet&lt;&gt;();         }         ConsumerSubscribeBo subscribeBo = new ConsumerSubscribeBo();         subscribeBo.setChannelId(channelId);         subscribeBo.setGroupName(serviceEntry.getGroupName());         subscribeBo.setTopicName(topicName);         subscribeBo.setTagRegex(serviceEntry.getTagRegex());         set.add(subscribeBo);          subscribeMap.put(topicName, set);          MqCommonResp resp = new MqCommonResp();         resp.setRespCode(MqCommonRespCode.SUCCESS.getCode());         resp.setRespMessage(MqCommonRespCode.SUCCESS.getMsg());         return resp;     }      @Override     public MqCommonResp unSubscribe(ConsumerUnSubscribeReq serviceEntry, Channel clientChannel) {         final String channelId = ChannelUtil.getChannelId(clientChannel);         final String topicName = serviceEntry.getTopicName();          ConsumerSubscribeBo subscribeBo = new ConsumerSubscribeBo();         subscribeBo.setChannelId(channelId);         subscribeBo.setGroupName(serviceEntry.getGroupName());         subscribeBo.setTopicName(topicName);         subscribeBo.setTagRegex(serviceEntry.getTagRegex());          // 集合         Set&lt;ConsumerSubscribeBo&gt; set = subscribeMap.get(topicName);         if(CollectionUtil.isNotEmpty(set)) {             set.remove(subscribeBo);         }          MqCommonResp resp = new MqCommonResp();         resp.setRespCode(MqCommonRespCode.SUCCESS.getCode());         resp.setRespMessage(MqCommonRespCode.SUCCESS.getMsg());         return resp;     }      @Override     public List&lt;Channel&gt; getSubscribeList(MqMessage mqMessage) {         final String topicName = mqMessage.getTopic();         Set&lt;ConsumerSubscribeBo&gt; set = subscribeMap.get(topicName);         if(CollectionUtil.isEmpty(set)) {             return Collections.emptyList();         }          //2. 获取匹配的 tag 列表         final List&lt;String&gt; tagNameList = mqMessage.getTags();          Map&lt;String, List&lt;ConsumerSubscribeBo&gt;&gt; groupMap = new HashMap&lt;&gt;();         for(ConsumerSubscribeBo bo : set) {             String tagRegex = bo.getTagRegex();              if(hasMatch(tagNameList, tagRegex)) {                 //TODO: 这种设置模式，统一添加处理                 String groupName = bo.getGroupName();                 List&lt;ConsumerSubscribeBo&gt; list = groupMap.get(groupName);                 if(list == null) {                     list = new ArrayList&lt;&gt;();                 }                 list.add(bo);                  groupMap.put(groupName, list);             }         }          //3. 按照 groupName 分组之后，每一组只随机返回一个。最好应该调整为以 shardingkey 选择         final String shardingKey = mqMessage.getShardingKey();         List&lt;Channel&gt; channelList = new ArrayList&lt;&gt;();          for(Map.Entry&lt;String, List&lt;ConsumerSubscribeBo&gt;&gt; entry : groupMap.entrySet()) {             List&lt;ConsumerSubscribeBo&gt; list = entry.getValue();              ConsumerSubscribeBo bo = RandomUtils.random(list, shardingKey);             BrokerServiceEntryChannel entryChannel = registerMap.get(bo.getChannelId());             channelList.add(entryChannel.getChannel());         }          return channelList;     }      private boolean hasMatch(List&lt;String&gt; tagNameList,                              String tagRegex) {         if(CollectionUtil.isEmpty(tagNameList)) {             return false;         }          Pattern pattern = Pattern.compile(tagRegex);          for(String tagName : tagNameList) {             if(RegexUtils.match(pattern, tagName)) {                 return true;             }         }          return false;     }  } </code></pre> <p><code>getSubscribeList</code> 的逻辑可能稍微复杂点，其实就是消息过来，找到匹配的订阅消费者而已。</p> <p>因为同一个 groupName 的消费者消息只消费一次，所以需要一次分组。</p> <h3 id="消息持久化">消息持久化</h3> <p>接口如下：</p> <pre><code class="language-java">package com.github.houbb.mq.broker.support.persist;  /**  * @author binbin.hou  * @since 0.0.3  */ public interface IMqBrokerPersist {      /**      * 保存消息      * @param mqMessage 消息      * @since 0.0.3      */     MqCommonResp put(final MqMessagePersistPut mqMessage);      /**      * 更新状态      * @param messageId 消息唯一标识      * @param status 状态      * @return 结果      * @since 0.0.3      */     MqCommonResp updateStatus(final String messageId,                               final String status);      /**      * 拉取消息      * @param pull 拉取消息      * @return 结果      */     MqConsumerPullResp pull(final MqConsumerPullReq pull, final Channel channel);  } </code></pre> <p>本地默认实现：</p> <pre><code class="language-java">package com.github.houbb.mq.broker.support.persist;  /**  * 本地持久化策略  * @author binbin.hou  * @since 1.0.0  */ public class LocalMqBrokerPersist implements IMqBrokerPersist {      private static final Log log = LogFactory.getLog(LocalMqBrokerPersist.class);      /**      * 队列      * ps: 这里只是简化实现，暂时不考虑并发等问题。      */     private final Map&lt;String, List&lt;MqMessagePersistPut&gt;&gt; map = new ConcurrentHashMap&lt;&gt;();      //1. 接收     //2. 持久化     //3. 通知消费     @Override     public synchronized MqCommonResp put(MqMessagePersistPut put) {         log.info("put elem: {}", JSON.toJSON(put));          MqMessage mqMessage = put.getMqMessage();         final String topic = mqMessage.getTopic();          List&lt;MqMessagePersistPut&gt; list = map.get(topic);         if(list == null) {             list = new ArrayList&lt;&gt;();         }         list.add(put);         map.put(topic, list);          MqCommonResp commonResp = new MqCommonResp();         commonResp.setRespCode(MqCommonRespCode.SUCCESS.getCode());         commonResp.setRespMessage(MqCommonRespCode.SUCCESS.getMsg());         return commonResp;     }      @Override     public MqCommonResp updateStatus(String messageId, String status) {         // 这里性能比较差，所以不可以用于生产。仅作为测试验证         for(List&lt;MqMessagePersistPut&gt; list : map.values()) {             for(MqMessagePersistPut put : list) {                 MqMessage mqMessage = put.getMqMessage();                 if(mqMessage.getTraceId().equals(messageId)) {                     put.setMessageStatus(status);                      break;                 }             }         }          MqCommonResp commonResp = new MqCommonResp();         commonResp.setRespCode(MqCommonRespCode.SUCCESS.getCode());         commonResp.setRespMessage(MqCommonRespCode.SUCCESS.getMsg());         return commonResp;     }      @Override     public MqConsumerPullResp pull(MqConsumerPullReq pull, Channel channel) {         //TODO... 待实现         return null;     }  } </code></pre> <p>ps: 后续将会基于 springboot+mysql 进行持久化策略实现。</p> </h1> <p>我们将生产者、消费者的启动都进行调整，连接到 broker 中。</p> <p>二者是类似的，此处以消费者为例。</p> <h2 id="核心启动类-1">核心启动类</h2> <pre><code class="language-java">package com.github.houbb.mq.consumer.core;  /**  * 推送消费策略  *  * @author binbin.hou  * @since 1.0.0  */ public class MqConsumerPush extends Thread implements IMqConsumer  {      // 属性&amp;设置      @Override     public void run() {         // 启动服务端         log.info("MQ 消费者开始启动服务端 groupName: {}, brokerAddress: {}",                 groupName, brokerAddress);          //1. 参数校验         this.paramCheck();          try {             // channel handler             ChannelHandler channelHandler = this.initChannelHandler();              //channel future             this.channelFutureList = ChannelFutureUtils.initChannelFutureList(brokerAddress, channelHandler);              // register to broker             this.registerToBroker();              // 标识为可用             enableFlag = true;             log.info("MQ 消费者启动完成");         } catch (Exception e) {             log.error("MQ 消费者启动异常", e);             throw new MqException(ConsumerRespCode.RPC_INIT_FAILED);         }     }      //订阅&amp;取消订阅      @Override     public void registerListener(IMqConsumerListener listener) {         this.mqListenerService.register(listener);     }  } </code></pre> <h3 id="初始化-handler">初始化 handler</h3> <pre><code class="language-java">private ChannelHandler initChannelHandler() {     final ByteBuf delimiterBuf = DelimiterUtil.getByteBuf(DelimiterUtil.DELIMITER);      final MqConsumerHandler mqConsumerHandler = new MqConsumerHandler(invokeService, mqListenerService);     // handler 实际上会被多次调用，如果不是 @Shareable，应该每次都重新创建。     ChannelHandler handler = new ChannelInitializer&lt;Channel&gt;() {         @Override         protected void initChannel(Channel ch) throws Exception {             ch.pipeline()                     .addLast(new DelimiterBasedFrameDecoder(DelimiterUtil.LENGTH, delimiterBuf))                     .addLast(mqConsumerHandler);         }     };      return handler; } </code></pre> <h3 id="注册到服务端">注册到服务端</h3> <pre><code class="language-java">/**  * 注册到所有的服务端  * @since 0.0.3  */ private void registerToBroker() {     for(RpcChannelFuture channelFuture : this.channelFutureList) {         ServiceEntry serviceEntry = new ServiceEntry();         serviceEntry.setGroupName(groupName);         serviceEntry.setAddress(channelFuture.getAddress());         serviceEntry.setPort(channelFuture.getPort());         serviceEntry.setWeight(channelFuture.getWeight());          BrokerRegisterReq brokerRegisterReq = new BrokerRegisterReq();         brokerRegisterReq.setServiceEntry(serviceEntry);         brokerRegisterReq.setMethodType(MethodType.C_REGISTER);         brokerRegisterReq.setTraceId(IdHelper.uuid32());          log.info("[Register] 开始注册到 broker：{}", JSON.toJSON(brokerRegisterReq));         final Channel channel = channelFuture.getChannelFuture().channel();         MqCommonResp resp = callServer(channel, brokerRegisterReq, MqCommonResp.class);         log.info("[Register] 完成注册到 broker：{}", JSON.toJSON(resp));     } } </code></pre> <h3 id="订阅与取消订阅">订阅与取消订阅</h3> <p>消费者对于关心的消息，实现也比较简单：</p> <pre><code class="language-java">public void subscribe(String topicName, String tagRegex) {     ConsumerSubscribeReq req = new ConsumerSubscribeReq();     String messageId = IdHelper.uuid32();     req.setTraceId(messageId);     req.setMethodType(MethodType.C_SUBSCRIBE);     req.setTopicName(topicName);     req.setTagRegex(tagRegex);     req.setGroupName(groupName);      Channel channel = getChannel();      MqCommonResp resp = callServer(channel, req, MqCommonResp.class);     if(!MqCommonRespCode.SUCCESS.getCode().equals(resp.getRespCode())) {         throw new MqException(ConsumerRespCode.SUBSCRIBE_FAILED);     } } </code></pre> <p>取消订阅：</p> <pre><code class="language-java">public void unSubscribe(String topicName, String tagRegex) {     ConsumerUnSubscribeReq req = new ConsumerUnSubscribeReq();     String messageId = IdHelper.uuid32();     req.setTraceId(messageId);     req.setMethodType(MethodType.C_UN_SUBSCRIBE);     req.setTopicName(topicName);     req.setTagRegex(tagRegex);     req.setGroupName(groupName);      Channel channel = getChannel();      MqCommonResp resp = callServer(channel, req, MqCommonResp.class);     if(!MqCommonRespCode.SUCCESS.getCode().equals(resp.getRespCode())) {         throw new MqException(ConsumerRespCode.UN_SUBSCRIBE_FAILED);     } } </code></pre> </h1> <h2 id="broker-启动">broker 启动</h2> <pre><code class="language-java">MqBroker broker = new MqBroker(); broker.start(); </code></pre> <p>启动日志：</p> <pre><code>[DEBUG] [2022-04-21 20:36:27.158] [main] [c.g.h.l.i.c.LogFactory.setImplementation] - Logging initialized using 'class com.github.houbb.log.integration.adaptors.stdout.StdOutExImpl' adapter. [INFO] [2022-04-21 20:36:27.186] [Thread-0] [c.g.h.m.b.c.MqBroker.run] - MQ 中间人开始启动服务端 port: 9999 [INFO] [2022-04-21 20:36:29.060] [Thread-0] [c.g.h.m.b.c.MqBroker.run] - MQ 中间人启动完成，监听【9999】端口 </code></pre> <h2 id="consumer-启动">consumer 启动</h2> <pre><code class="language-java">final MqConsumerPush mqConsumerPush = new MqConsumerPush(); mqConsumerPush.start();  mqConsumerPush.subscribe("TOPIC", "TAGA"); mqConsumerPush.registerListener(new IMqConsumerListener() {     @Override     public ConsumerStatus consumer(MqMessage mqMessage, IMqConsumerListenerContext context) {         System.out.println("---------- 自定义 " + JSON.toJSONString(mqMessage));         return ConsumerStatus.SUCCESS;     } }); </code></pre> <p>启动日志：</p> <pre><code>... [INFO] [2022-04-21 20:37:40.985] [Thread-0] [c.g.h.m.c.c.MqConsumerPush.registerToBroker] - [Register] 完成注册到 broker：{"respMessage":"成功","respCode":"0000"} </code></pre> <p>启动时会注册到 broker。</p> <h2 id="producer-启动">producer 启动</h2> <pre><code class="language-java">MqProducer mqProducer = new MqProducer(); mqProducer.start(); String message = "HELLO MQ!"; MqMessage mqMessage = new MqMessage(); mqMessage.setTopic("TOPIC"); mqMessage.setTags(Arrays.asList("TAGA", "TAGB")); mqMessage.setPayload(message);  SendResult sendResult = mqProducer.send(mqMessage);  System.out.println(JSON.toJSON(sendResult)); </code></pre> <p>日志：</p> <pre><code>... [INFO] [2022-04-21 20:39:17.885] [Thread-0] [c.g.h.m.p.c.MqProducer.registerToBroker] - [Register] 完成注册到 broker：{"respMessage":"成功","respCode":"0000"} ... </code></pre> <p>此时消费者消费到我们发送的消息。</p> <pre><code>---------- 自定义 {"methodType":"B_MESSAGE_PUSH","payload":"HELLO MQ!","tags":["TAGA","TAGB"],"topic":"TOPIC","traceId":"2237bbfe55b842328134e6a100e36364"} </code></pre> </h1> <p>到这里，我们就实现了基于中间人的生产者与消费者通讯。</p> <p>希望本文对你有所帮助，如果喜欢，欢迎点赞收藏转发一波。</p> <p>我是老马，期待与你的下次重逢。</p> </h1> <blockquote> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://github.com/houbb/mq"  target="_blank"  rel="nofollow">The message queue in java.(java 简易版本 mq 实现) </a> <a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://github.com/houbb/mq"  target="_blank"  rel="nofollow">https://github.com/houbb/mq</a></p> </blockquote> </h1> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://github.com/houbb/rpc"  target="_blank"  rel="nofollow">rpc-从零开始实现 rpc</a> <a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://github.com/houbb/rpc"  target="_blank"  rel="nofollow">https://github.com/houbb/rpc</a></p> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-23506.htm">国内十大宠物粮食品牌（国内十大宠物粮食品牌排名）</a></p>
                                        <p>下一个：<a href="/news/article-23963.htm">南京宠物领养中心电话多少 南京宠物领养中心电话多少号</a></p>
                                    </div>
                                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/news/article-30973.htm" title="宠物领养协议书范本最新图片高清大图（宠物领养协议简单版本）">宠物领养协议书范本最新图片高清大图（宠物领养协议简单版本）</a></li>
                        <li class="py-2"><a href="/news/article-45121.htm" title="动物疫苗去哪买便宜（动物疫苗那里买）">动物疫苗去哪买便宜（动物疫苗那里买）</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-2-17-free-clash-subscribe.htm" title="「2月17日」最高速度20M/S，2025年Clash Nyanpasu每天更新免费节点订阅链接，高速机场推荐">「2月17日」最高速度20M/S，2025年Clash Nyanpasu每天更新免费节点订阅链接，高速机场推荐</a></li>
                        <li class="py-2"><a href="/news/article-62931.htm" title="兽用疫苗稀释液的说明书（兽用疫苗稀释液是什么成分）">兽用疫苗稀释液的说明书（兽用疫苗稀释液是什么成分）</a></li>
                        <li class="py-2"><a href="/news/article-46608.htm" title="详解盒子模型和div布局">详解盒子模型和div布局</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-12-11-free-clash-nyanpasu.htm" title="「12月11日」最高速度19.3M/S，2024年Clash Nyanpasu每天更新免费节点订阅链接，高速机场推荐">「12月11日」最高速度19.3M/S，2024年Clash Nyanpasu每天更新免费节点订阅链接，高速机场推荐</a></li>
                        <li class="py-2"><a href="/news/article-22132.htm" title="我们城市有个动物园英语 我们城市有个动物园英语怎么说">我们城市有个动物园英语 我们城市有个动物园英语怎么说</a></li>
                        <li class="py-2"><a href="/news/article-55460.htm" title="成人高考兽医专业可以考兽医资格证吗（成人高考的动物医学专业能参加兽医证）">成人高考兽医专业可以考兽医资格证吗（成人高考的动物医学专业能参加兽医证）</a></li>
                        <li class="py-2"><a href="/news/article-43127.htm" title="宠物领养app的名字叫什么好听（宠物领养app的名字叫什么好听一点）">宠物领养app的名字叫什么好听（宠物领养app的名字叫什么好听一点）</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-1-14-free-high-speed-nodes.htm" title="「1月14日」最高速度21.3M/S，2025年Clash Nyanpasu每天更新免费节点订阅链接，高速机场推荐">「1月14日」最高速度21.3M/S，2025年Clash Nyanpasu每天更新免费节点订阅链接，高速机场推荐</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">6</span> <a href="/date/2025-03/" title="2025-03 归档">2025-03</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">84</span> <a href="/date/2025-02/" title="2025-02 归档">2025-02</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">92</span> <a href="/date/2025-01/" title="2025-01 归档">2025-01</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">87</span> <a href="/date/2024-12/" title="2024-12 归档">2024-12</a></h4>
            </li>
                    </ul>
    </div>
</div>

                </div>
            </div>
        </div>
    </section>
        <!--====== FOOTER PART START ======-->
    <section class="footer-area footer-dark">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-lg-6">
                    <div class="copyright text-center mt-35">
                            <p>
                                <a href="/">首页</a> | 
                                <a href="/free-node/">免费节点</a> | 
                                <a href="/news/">新闻资讯</a> |
                                <a href="/about-us.htm">关于我们</a> |
                                <a href="/disclaimer.htm">免责申明</a> |
                                <a href="/privacy.htm">隐私申明</a> |
                                <a href="/sitemap.xml">网站地图</a>
                            </p>
                        <p class="text">
                            ClashNyanpasu官网节点站 版权所有 Powered by WordPress
                        </p>
                    </div> <!--  copyright -->
                </div>
            </div> <!-- row -->
        </div> <!-- container -->
    </section>
    <!--====== FOOTER PART ENDS ======-->
    <!--====== BACK TOP TOP PART START ======-->
    <a href="#" class="back-to-top"><i class="lni lni-chevron-up"></i></a>
    <!--====== BACK TOP TOP PART ENDS ======-->
    <!--====== Jquery js ======-->
    <script src="/assets/website/js/frontend/clashnyanpasu/vendor/jquery-1.12.4.min.js"></script>
    <script src="/assets/website/js/frontend/clashnyanpasu/vendor/modernizr-3.7.1.min.js"></script>
    <!--====== Bootstrap js ======-->
    <script src="/assets/website/js/frontend/clashnyanpasu/popper.min.js"></script>
    <script src="/assets/website/js/frontend/clashnyanpasu/bootstrap.min.js"></script>
    <script src="/assets/website/js/frontend/clashnyanpasu/slick.min.js"></script>
    <script src="/assets/website/js/frontend/clashnyanpasu/jquery.magnific-popup.min.js"></script>
    <script src="/assets/website/js/frontend/clashnyanpasu/ajax-contact.js"></script>
    <!--====== Isotope js ======-->
    <script src="/assets/website/js/frontend/clashnyanpasu/imagesloaded.pkgd.min.js"></script>
    <script src="/assets/website/js/frontend/clashnyanpasu/isotope.pkgd.min.js"></script>
    <!--====== Scrolling Nav js ======-->
    <script src="/assets/website/js/frontend/clashnyanpasu/jquery.easing.min.js"></script>
    <script src="/assets/website/js/frontend/clashnyanpasu/scrolling-nav.js"></script>
    <!--====== Main js ======-->
    <script src="/assets/website/js/frontend/clashnyanpasu/main.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>